<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>خلسه</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #d32f2f;
            --background-color: #000;
            --text-color: #b0bec5;
        }
        html, body {
            width: 100%; height: 100%; margin: 0; padding: 0;
            background: var(--background-color);
            cursor: none; font-family: 'Vazirmatn', sans-serif;
            user-select: none; overflow: hidden;
        }
        #app-container, #visual-engine, #ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
        }
        #ui-layer { z-index: 10; display: flex; justify-content: center; align-items: center; text-align: center; padding: 1rem; color: var(--text-color); }
        #content-wrapper { width: 95%; max-width: 800px; }
        #cursor-follower {
            position: fixed; width: 20px; height: 20px;
            border-radius: 50%; border: 2px solid var(--text-color);
            pointer-events: none; z-index: 9999; mix-blend-mode: difference;
            transition: transform 0.1s ease-out, opacity 0.3s ease;
            will-change: transform; opacity: 0;
        }

        /* انیمیشن‌های جدید و بهبودیافته */
        @keyframes text-flicker-in {
          0% { opacity: 0; text-shadow: none; filter: blur(5px); }
          10% { opacity: 1; text-shadow: 0 0 5px #ff0000, 0 0 10px #0000ff; }
          12% { opacity: 0.3; }
          20% { opacity: 1; text-shadow: 0 0 5px #ff0000, 0 0 10px #0000ff; }
          25% { opacity: 0.6; }
          30% { opacity: 1; transform: translateX(2px); }
          40% { opacity: 0.8; transform: translateX(-2px); filter: blur(0); }
          50% { opacity: 1; transform: none; text-shadow: none; }
          100% { opacity: 1; }
        }
        @keyframes fadeOut-glitch {
            from { opacity: 1; filter: blur(0); }
            to { opacity: 0; filter: blur(5px) drop-shadow(0 0 10px var(--primary-color)); transform: scale(0.9); }
        }
        .animated-content { animation: text-flicker-in 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
        .interactive-button, .interactive-submit, .mic-button {
            background: transparent; border: 1px solid var(--primary-color); color: var(--primary-color);
            padding: 10px 20px; font-size: 1.1rem; transition: all 0.2s; margin: 5px;
            display: inline-flex; align-items: center; justify-content: center; text-shadow: 0 0 5px transparent;
        }
        .interactive-button:hover:not(:disabled), .interactive-submit:hover, .mic-button:hover:not(:disabled) { 
            background: var(--primary-color); color: var(--background-color); 
            box-shadow: 0 0 20px var(--primary-color), 0 0 30px var(--primary-color); 
            transform: scale(1.05); text-shadow: 0 0 5px var(--background-color);
        }
        .interactive-button:disabled, .mic-button:disabled { opacity: 0.5; cursor: not-allowed; }
        .mic-button.is-listening { background: var(--primary-color); color: var(--background-color); animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.7); } 70% { box-shadow: 0 0 0 20px rgba(211, 47, 47, 0); } 100% { box-shadow: 0 0 0 0 rgba(211, 47, 47, 0); } }
        .interactive-input {
            background: transparent; color: #fff; border: none; border-bottom: 2px solid var(--text-color);
            text-align: center; width: 80%; max-width: 450px; font-size: 2rem; padding: 5px; transition: all 0.3s;
        }
        .interactive-input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 5px 15px -10px var(--primary-color); }
        .color-palette { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; margin-top: 2rem; }
        .color-swatch { width: 60px; height: 60px; border-radius: 50%; border: 2px solid transparent; transition: all 0.2s; }
        .color-swatch:hover { transform: scale(1.15); border-color: #fff; box-shadow: 0 0 20px currentColor; }
        #feedback-text { font-size: 1.5rem; font-style: italic; color: #64b5f6; text-shadow: 0 0 10px #64b5f6; }
    </style>
</head>
<body>
    <div id="app-container">
        <canvas id="visual-engine"></canvas>
        <div id="ui-layer"><div id="content-wrapper"></div></div>
    </div>
    <div id="cursor-follower"></div>

    <script>
        // ===================================================================================
        // UTILITIES & CUSTOM ERRORS
        // ===================================================================================
        class NonRetryableError extends Error {
            constructor(message) { super(message); this.name = "NonRetryableError"; }
        }

        // ===================================================================================
        // CORE MODULE: The Game's Soul
        // ===================================================================================
        const Engine = {
            state: {
                currentFlow: 'intro', distortion: 0,
                userProfile: { name: 'مسافر', choices: [] },
                lastInput: null, isAudioReady: false,
            },

            init() {
                UI.init(); Visuals.init(); Voice.init();
                UI.renderIntro();
            },

            async primeAudioAndStart() {
                try {
                    if (!this.state.isAudioReady) {
                        await Tone.start();
                        Audio.init();
                        this.state.isAudioReady = true;
                    }
                    this.startExperience();
                } catch(e) {
                    console.error("Audio Context Failed To Start:", e);
                    UI.renderError("خطا در زمینه صوتی. بازی بدون صدا ادامه می‌یابد.");
                    setTimeout(() => this.startExperience(), 2000);
                }
            },

            startExperience() { this.transitionTo('loading_stage'); },

            async transitionTo(flowState, context = {}) {
                this.state.currentFlow = flowState;
                let stageData, feedbackData, stageType;
                try {
                    switch (flowState) {
                        case 'loading_stage':
                            await UI.renderLoader("طنین در حال یافتن توست...");
                            stageType = this.determineNextStage();
                            stageData = await AI.generateStage(stageType, this.state.userProfile);
                            if (!stageData) throw new Error("AI returned no data");
                            this.transitionTo('stage', { type: stageType, data: stageData });
                            break;
                        case 'stage': UI.renderStage(context.type, context.data); break;
                        case 'loading_feedback':
                            await UI.renderLoader("در حال تحلیل پاسخ تو...");
                            feedbackData = await AI.generateFeedback(this.state.lastInput);
                            if (!feedbackData) throw new Error("AI returned no feedback");
                            this.transitionTo('feedback', { data: feedbackData });
                            break;
                        case 'feedback':
                            await UI.renderFeedback(context.data.comment);
                            setTimeout(() => this.transitionTo('loading_stage'), 5000);
                            break;
                        default: throw new Error(`Unknown flow state: ${flowState}`);
                    }
                } catch (e) {
                    if (e instanceof NonRetryableError) this.handleAIFatalError(e);
                    else this.handleAITemporaryFailure(() => this.transitionTo(flowState, context));
                }
            },
            
            determineNextStage() {
                const stages = ['question', 'color_game', 'word_association'];
                if (this.state.distortion > 2) stages.push('number_game', 'audio_distortion', 'dream_journal');
                if (this.state.distortion > 5) stages.push('rorschach_test', 'pattern_intrusion');
                if (this.state.distortion > 10 && this.state.userProfile.choices.length > 2) stages.push('memory_corruption');
                return stages[Math.floor(Math.random() * stages.length)];
            },
            
            handleAITemporaryFailure(retryFunction) {
                console.warn("Temporary AI failure. Retrying in 7 seconds.");
                UI.renderLoader("ارتباط با طنین ناپایدار است. در حال تلاش برای اتصال مجدد...");
                setTimeout(() => retryFunction(), 7000);
            },

            handleAIFatalError(error) {
                console.error("Entity Communication Failed:", error);
                let msg = `یک خطای غیرقابل بازیابی رخ داد: ${error.message}. لطفاً صفحه را رفرش کنید.`;
                UI.renderError(msg);
            },

            processUserInput(inputData) {
                this.state.lastInput = inputData;
                this.state.userProfile.choices.push(inputData);
                const collapseAmount = inputData.collapse || 1;
                this.state.distortion += collapseAmount;
                Visuals.update(this.state.distortion);
                if (this.state.isAudioReady) Audio.update(this.state.distortion);
                this.transitionTo('loading_feedback');
            }
        };
        
        // ===================================================================================
        // UI MODULE: The Visual Interface
        // ===================================================================================
        const UI = {
            init() {
                const cursor = document.getElementById('cursor-follower');
                window.addEventListener('mousemove', e => {
                    cursor.style.opacity = '1';
                    cursor.style.transform = `translate3d(${e.clientX}px, ${e.clientY}px, 0)`;
                });
                document.body.addEventListener('mouseleave', () => { cursor.style.opacity = '0'; });
            },

            _setContent(html) {
                return new Promise(res => {
                    const wrapper = document.getElementById('content-wrapper');
                    wrapper.style.animation = 'fadeOut-glitch 0.5s forwards';
                    if (Audio.isSetup) Audio.playSFX('swoosh');
                    
                    setTimeout(() => {
                        wrapper.innerHTML = html;
                        wrapper.className = 'animated-content';
                        res();
                    }, 500);
                });
            },
            
            renderIntro() {
               this._setContent(`
                    <h1 class="text-6xl font-black" style="text-shadow: 0 0 15px var(--primary-color);">خلسه</h1>
                    <p class="mt-4 text-gray-500">یک هم‌صحبت، در انتظار توست.</p>
                    <button id="start-btn" class="interactive-button mt-8">آغاز کن</button>
                `).then(() => {
                    const btn = document.getElementById('start-btn');
                    btn.onmouseenter = () => Audio.playSFX('hover');
                    btn.onclick = () => { Audio.playSFX('click'); Engine.primeAudioAndStart(); };
                });
            },
            
            renderLoader(text) { return this._setContent(`<p class="text-2xl text-gray-400">${text}</p>`); },
            renderError(msg) { return this._setContent(`<p class="text-2xl text-red-500">${msg}</p>`); },
            renderFeedback(comment) { return this._setContent(`<p id="feedback-text">"${comment}"</p>`); },

            renderStage(type, data) {
                let html = '';
                let hasTextInput = false;

                switch(type) {
                    case 'question':
                    case 'pattern_intrusion':
                        html = `<p class="text-2xl md:text-3xl mb-8">${data.prompt}</p><div data-stage-type="${type}">${data.choices.map(c => `<button class="interactive-button" data-collapse="${c.collapse}">${c.text}</button>`).join('')}</div>`;
                        if (type === 'pattern_intrusion') Visuals.triggerPattern(data.pattern);
                        break;
                    case 'color_game':
                        html = `<p class="text-2xl md:text-3xl mb-8">${data.prompt}</p><div class="color-palette" data-stage-type="${type}">${data.colors.map(c => `<div class="color-swatch" style="background-color: ${c.hex};" data-collapse="${c.collapse}" data-meaning="${c.meaning}"></div>`).join('')}</div>`;
                        break;
                    case 'audio_distortion':
                        html = `<p class="text-2xl md:text-3xl mb-8">${data.prompt}</p>
                                <div data-stage-type="${type}">
                                   <button class="interactive-button" data-choice="آرامش" data-collapse="1">آرامش</button>
                                   <button class="interactive-button" data-choice="اضطراب" data-collapse="3">اضطراب</button>
                                </div>`;
                        if (Audio.isSetup) Audio.playDistortedSound(data.sound, data.params);
                        break;
                    case 'rorschach_test': Visuals.drawRorschach(); hasTextInput = true; break;
                    case 'memory_corruption': case 'number_game': case 'word_association': case 'dream_journal': hasTextInput = true; break;
                    default: html = `<p class="text-2xl text-red-500">خطای مرحله.</p>`;
                }
                
                if (hasTextInput) {
                    html = `<div data-stage-type="${type}">
                                <p class="text-2xl md:text-3xl mb-8">${data.prompt || "پاسخ بده..."}</p>
                                <div class="flex flex-col items-center gap-4">
                                    <input type="text" class="interactive-input" id="text-input" autocomplete="off" placeholder="پاسخ تو...">
                                    <div class="flex items-center gap-4 mt-4">
                                        <button class="interactive-submit" id="submit-btn">ثبت</button>
                                        <button class="mic-button" id="mic-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg></button>
                                    </div>
                                </div>
                            </div>`;
                }
                this._setContent(html).then(() => this.setupStageListeners(type));
            },
            
            setupStageListeners(type) {
                document.querySelectorAll('.interactive-button, .interactive-submit, .mic-button, .color-swatch').forEach(el => {
                    el.onmouseenter = () => Audio.playSFX('hover');
                });
                
                const processClick = (data) => { Audio.playSFX('click'); Engine.processUserInput(data); };
                
                document.querySelectorAll('.interactive-button').forEach(btn => {
                    btn.onclick = () => processClick({ type: type, choice: btn.dataset.choice || btn.innerText, collapse: parseInt(btn.dataset.collapse || 1) });
                });
                
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.onclick = () => processClick({ type: type, choice: swatch.dataset.meaning, collapse: parseInt(swatch.dataset.collapse || 1) });
                });

                const submitBtn = document.getElementById('submit-btn');
                const textInput = document.getElementById('text-input');
                if (submitBtn && textInput) {
                    const action = () => { if (textInput.value.trim()) processClick({ type: type, choice: textInput.value, collapse: 2 }); };
                    submitBtn.onclick = action;
                    textInput.onkeydown = e => { if (e.key === 'Enter') action(); };
                }

                const micBtn = document.getElementById('mic-btn');
                if (micBtn) micBtn.onclick = () => { Audio.playSFX('click'); Voice.requestAndListen(); };
            }
        };

        // ===================================================================================
        // VOICE MODULE: Handles Speech Recognition & Visualizer
        // ===================================================================================
        const Voice = {
            recognition: null, isSupported: ('webkitSpeechRecognition' in window),
            permissionState: 'prompt', userAudioStream: null,
            
            init() { /* ... unchanged ... */ },

            async requestAndListen() {
                const micBtn = document.getElementById('mic-btn');
                if(micBtn) micBtn.disabled = true;

                try {
                    if (!this.userAudioStream) {
                        this.userAudioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        this.permissionState = 'granted';
                        const source = Tone.context.createMediaStreamSource(this.userAudioStream);
                        const analyser = new Tone.Analyser('waveform', 1024);
                        source.connect(analyser);
                        Visuals.setVoiceAnalyser(analyser);
                    }
                    this.listen();
                } catch (err) { /* ... unchanged error handling ... */ } 
                finally { if(micBtn) micBtn.disabled = false; }
            },

            listen() {
                if (this.recognition && this.recognition.abort) this.recognition.abort();
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                Object.assign(this.recognition, { continuous: false, lang: 'fa-IR', interimResults: true });
                
                const micBtn = document.getElementById('mic-btn'), textInput = document.getElementById('text-input');
                this.recognition.onstart = () => { micBtn.classList.add('is-listening'); textInput.placeholder = 'در حال شنیدن...'; Visuals.isVoiceActive = true; };
                this.recognition.onend = () => { micBtn.classList.remove('is-listening'); Visuals.isVoiceActive = false; /* ... rest is unchanged ... */ };
                /* ... onresult, onerror are unchanged ... */
                try { this.recognition.start(); } catch(e) { console.error("Recognition already started."); }
            }
        };

        // ===================================================================================
        // AI MODULE: The Entity's Mind
        // ===================================================================================
        const AI = {
            async _query(prompt, retries = 3, backoff = 2000) { /* ... unchanged from previous step ... */ },
            
            async generateStage(type, profile) {
                let prompt;
                switch (type) {
                    case 'question': prompt = `یک سوال دو گزینه‌ای فلسفی با لحن کوچه‌بازاری و تهاجمی طراحی کن. موضوعات: انتخاب بین بد و بدتر، حقیقت تلخ یا دروغ شیرین. خروجی JSON: {"prompt": "متن سوال", "choices": [{"text": "متن گزینه", "collapse": امتیاز}]}`; break;
                    case 'color_game': prompt = `یک سوال انتزاعی بپرس که کاربر با یک رنگ پاسخ دهد. مثلا "رنگ «بغض» چیه؟". یک پالت ۶ تایی رنگ با معانی تاریک و امتیاز فروپاشی بده. خروجی JSON: {"prompt": "سوال", "colors": [{"hex": "#کدرنگ", "meaning": "معنی", "collapse": امتیاز}]}`; break;
                    case 'number_game': prompt = `یک سوال روانشناختی بپرس که پاسخش یک عدد باشد. با لحن بی‌رحم. مثال: "چند نفر رو باید قربانی کنی تا خودت زنده بمونی؟". خروجی JSON: {"prompt": "سوال"}`; break;
                    case 'memory_corruption': const choice = profile.choices.length > 0 ? profile.choices[Math.floor(Math.random() * profile.choices.length)] : { choice: "سکوت" }; prompt = `پاسخ قبلی کاربر "${choice.choice}" بوده. اینو تحریف کن و ازش بپرس چرا اینو گفته. مثال: اگر گفته "امید"، بپرس "یادمه میگفتی امید یه جور خودفریبیه. چرا؟". سوال باید کاربر رو به حافظه‌ش شکاک کنه. خروجی JSON: {"prompt": "سوال تحریف شده"}`; break;
                    case 'rorschach_test': prompt = `یک سوال مرموز بپرس. "توی این لکه چی می‌بینی؟ چیزی که ازش فرار می‌کنی یا چیزی که دنبالشی؟". خروجی JSON: {"prompt": "سوال"}`; break;
                    case 'word_association': prompt = `یک سوال "تداعی کلمات" با کلمه‌ای مثل «انتقام» یا «تنهایی» بپرس. خروجی JSON: {"prompt": "اولین کلمه‌ای که با شنیدن «انتقام» میاد تو ذهنت چیه؟"}`; break;
                    case 'dream_journal': prompt = `یک سوال درباره آخرین رویای کاربر بپرس. کوتاه و مبهم. خروجی JSON: {"prompt": "آخرین خوابی که دیدی رو در یک کلمه توصیف کن."}`; break;
                    case 'audio_distortion': prompt = `یک صدای انتزاعی برای کاربر پخش می‌شود. یک سوال کوتاه بپرس که آیا این صدا حس آرامش می‌دهد یا اضطراب. همچنین نوع صدا (مثلا "wind" یا "synth") و پارامترهای افکت صوتی را مشخص کن. خروجی JSON: {"prompt": "این نوا به تو چه حسی می‌دهد؟", "sound": "synth", "params": {"distortion": 0.6, "reverb": 0.8}}`; break;
                    case 'pattern_intrusion': prompt = `یک بازی کشف ناهنجاری طراحی کن. یک الگوی تکرارشونده و یک عنصر ناهنجار بده. سپس دو گزینه برای پاسخ بده. خروجی JSON: {"prompt": "ناهنجاری کجاست؟", "pattern": {"base": "O", "intruder": "0", "count": 25}, "choices": [{"text": "در نیمه اول", "collapse": 1}, {"text": "در نیمه دوم", "collapse": 2}]}`; break;
                    default: prompt = `یک سوال اگزیستانسیال عجیب بپرس. خروجی JSON: {"prompt": "اگر پژواک بودی، دوست داشتی در کدام دره تکرار شوی؟"}`;
                }
                return this._query(prompt);
            },
            
            async generateFeedback(lastInput) { /* ... unchanged ... */ }
        };

        // ===================================================================================
        // VISUALS MODULE: The Game's Canvas Soul
        // ===================================================================================
        const Visuals = {
            ctx: null, width: 0, height: 0,
            particles: [], cursorParticles: [],
            glitchIntensity: 0, glitchCounter: 0,
            voiceAnalyser: null, isVoiceActive: false,
            mouse: { x: 0, y: 0 },
            pattern: null, patternTimeout: null,

            init() {
                this.ctx = document.getElementById('visual-engine').getContext('2d');
                this.resize(); window.addEventListener('resize', () => this.resize());
                window.addEventListener('mousemove', e => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; });
                this.createParticles(50); this.loop();
            },
            resize() { this.width = this.ctx.canvas.width = window.innerWidth; this.height = this.ctx.canvas.height = window.innerHeight; },
            setVoiceAnalyser(analyser) { this.voiceAnalyser = analyser; },
            update(distortion) {
                if (Math.random() < distortion / 50) this.triggerGlitch(distortion / 10);
                if (this.particles.length < 50 + distortion * 5) this.createParticles(1);
            },
            triggerGlitch(intensity) { this.glitchIntensity = intensity; this.glitchCounter = 10; },
            createParticles(count) { for (let i = 0; i < count; i++) this.particles.push({ x: Math.random() * this.width, y: Math.random() * this.height, vx: Math.random() - 0.5, vy: Math.random() - 0.5, life: 500 + Math.random() * 500, radius: Math.random() * 1.5 }); },
            drawRorschach() { /* ... unchanged ... */ },
            triggerPattern(patternData) { this.pattern = patternData; clearTimeout(this.patternTimeout); this.patternTimeout = setTimeout(() => this.pattern = null, 2000); },
            
            loop() {
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                this.handleParticles(); this.handleCursorTrail();
                if (this.isVoiceActive && this.voiceAnalyser) this.drawVoiceVisualizer();
                if (this.pattern) this.drawPattern();
                if (this.glitchCounter > 0) { this.drawGlitch(); this.glitchCounter--; }
                requestAnimationFrame(() => this.loop());
            },

            handleParticles() {
                const df = 1 + Engine.state.distortion / 20;
                this.ctx.fillStyle = `rgba(211, 47, 47, ${0.2 + (Engine.state.distortion / 50)})`;
                this.particles.forEach((p, i) => {
                    p.x += p.vx * df; p.y += p.vy * df; p.life--;
                    if (p.x > this.width || p.x < 0 || p.y > this.height || p.y < 0 || p.life <= 0) { this.particles.splice(i, 1); return; }
                    this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); this.ctx.fill();
                });
            },
            
            handleCursorTrail() {
                this.cursorParticles.push({ x: this.mouse.x, y: this.mouse.y, life: 50, radius: Math.random() * 2 + 1 });
                this.cursorParticles.forEach((p, i) => {
                    p.life--; if (p.life <= 0) { this.cursorParticles.splice(i, 1); return; }
                    this.ctx.beginPath(); this.ctx.fillStyle = `rgba(176, 190, 197, ${p.life / 50 * 0.5})`; this.ctx.arc(p.x, p.y, p.radius * (p.life / 50), 0, Math.PI * 2); this.ctx.fill();
                });
            },

            drawVoiceVisualizer() {
                const values = this.voiceAnalyser.getValue();
                this.ctx.strokeStyle = `rgba(211, 47, 47, ${0.4 + Math.random() * 0.4})`; this.ctx.lineWidth = 2; this.ctx.beginPath();
                const sliceWidth = this.width / values.length; let x = 0;
                for (let i = 0; i < values.length; i++) {
                    const v = values[i] * 2; const y = (v * this.height / 2) + this.height / 2;
                    if (i === 0) this.ctx.moveTo(x, y); else this.ctx.lineTo(x, y);
                    x += sliceWidth;
                }
                this.ctx.stroke();
            },

            drawPattern() {
                this.ctx.fillStyle = 'rgba(200, 200, 200, 0.9)'; this.ctx.font = '24px monospace'; this.ctx.textAlign = 'center';
                const { base, intruder, count } = this.pattern;
                const intruderIndex = Math.floor(Math.random() * count);
                const cols = 10; const rows = Math.ceil(count / cols);
                for (let i = 0; i < count; i++) {
                    const char = (i === intruderIndex) ? intruder : base;
                    const x = this.width / 2 + (i % cols - cols/2) * 30;
                    const y = this.height / 2 + (Math.floor(i / cols) - rows/2) * 40;
                    this.ctx.fillText(char, x + (Math.random()-0.5)*5, y + (Math.random()-0.5)*5);
                }
            },

            drawGlitch() {
                for (let i = 0; i < this.glitchIntensity; i++) {
                    const x = Math.random() * this.width, y = Math.random() * this.height;
                    const w = Math.random() * (this.width / 4), h = Math.random() * (this.height / 10);
                    this.ctx.drawImage(this.ctx.canvas, Math.random() * this.width, Math.random() * this.height, w, h, x, y, w, h);
                }
                this.ctx.globalCompositeOperation = 'lighter';
                this.ctx.fillStyle = `rgba(255, 0, 0, ${Math.random() * 0.1})`; this.ctx.fillRect(0,0,this.width,this.height);
                this.ctx.fillStyle = `rgba(0, 0, 255, ${Math.random() * 0.1})`; this.ctx.fillRect(0,0,this.width,this.height);
                this.ctx.globalCompositeOperation = 'source-over';
            }
        };
        
        // ===================================================================================
        // AUDIO MODULE: The Game's Voice
        // ===================================================================================
        const Audio = {
            isSetup: false, sfx: {},
            init() {
                if (this.isSetup) return;
                this.reverb = new Tone.Reverb({ decay: 4, wet: 0.5 }).toDestination();
                this.wind = new Tone.Noise("pink").connect(new Tone.AutoFilter({ frequency: "8m", baseFrequency: 100, octaves: 4 }).connect(this.reverb));
                this.wind.volume.value = -30; this.wind.start();
                this.sfx.hover = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }, volume: -20 }).toDestination();
                this.sfx.click = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0 }, volume: -15 }).toDestination();
                this.sfx.swoosh = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.2, decay: 0.3, sustain: 0 }, volume: -18 }).connect(new Tone.Filter(800, 'lowpass')).toDestination();
                this.isSetup = true;
            },
            update(distortion) {
                if (!this.isSetup) return;
                this.wind.volume.rampTo(Math.min(-15, -30 + distortion * 1.5), 2);
                this.reverb.wet.rampTo(Math.min(0.9, 0.5 + distortion / 50), 2);
            },
            playSFX(type) {
                if (!this.isSetup || !this.sfx[type]) return;
                if (type === 'hover') this.sfx.hover.triggerAttackRelease('C5', '32n');
                else if (type === 'click') this.sfx.click.triggerAttackRelease('C2', '8n');
                else if (type === 'swoosh') this.sfx.swoosh.triggerAttack();
            },
            playDistortedSound(sound, params) {
                const synth = new Tone.FMSynth({ harmonicity: 1.5, modulationIndex: 5 }).toDestination();
                const distortion = new Tone.Distortion(params.distortion || 0.5).connect(this.reverb);
                synth.connect(distortion);
                synth.triggerAttackRelease('C2', '1n', Tone.now());
                setTimeout(() => synth.dispose(), 1500);
            }
        };

        // --- APPLICATION LAUNCH ---
        Engine.init();
    </script>
</body>
</html>
