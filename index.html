<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>خلسه</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #d32f2f;
            --primary-light: #ef5350;
            --background-color: #0d0d0d;
            --text-color: #e0e0e0;
            --secondary-text-color: #9e9e9e;
            --accent-color: #64b5f6;
            --error-color: #f44336;
            --glow-color: rgba(211, 47, 47, 0.6);
        }
        html, body {
            width: 100%; height: 100%; margin: 0; padding: 0;
            background: var(--background-color);
            cursor: none;
            font-family: 'Vazirmatn', sans-serif;
            user-select: none;
            overflow: hidden;
        }
        #app-container, #visual-engine, #ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
        }
        #ui-layer {
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 1rem;
            color: var(--text-color);
            pointer-events: none;
        }
        #ui-layer > div {
            pointer-events: all;
        }
        #content-wrapper {
            width: 95%; max-width: 800px;
            background: rgba(0, 0, 0, 0.4);
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #cursor-follower {
            position: fixed; width: 25px; height: 25px;
            border-radius: 50%;
            border: 2px solid var(--accent-color);
            pointer-events: none; z-index: 9999;
            mix-blend-mode: exclusion;
            transition: transform 0.1s ease-out, opacity 0.3s ease, border-color 0.5s ease;
            will-change: transform; opacity: 0;
            transform: translate3d(-50%, -50%, 0);
        }
        @keyframes fadeIn { from { opacity: 0; filter: blur(5px); transform: scale(0.95); } to { opacity: 1; filter: blur(0); transform: scale(1); } }
        @keyframes fadeOut { from { opacity: 1; filter: blur(0); transform: scale(1); } to { opacity: 0; filter: blur(5px); transform: scale(0.95); } }
        .interactive-button, .interactive-submit, .mic-button {
            background: transparent;
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
            padding: 12px 25px;
            font-size: 1.1rem;
            border-radius: 8px;
            transition: all 0.3s ease;
            margin: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px rgba(211, 47, 47, 0.3);
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }
        .interactive-button::before, .interactive-submit::before, .mic-button::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.4s ease, height 0.4s ease;
            opacity: 0;
        }
        .interactive-button:hover::before, .interactive-submit:hover::before, .mic-button:hover::before {
            width: 200%; height: 200%;
            opacity: 1;
        }
        .interactive-button:hover:not(:disabled), .interactive-submit:hover, .mic-button:hover:not(:disabled) {
            background: var(--primary-color);
            color: var(--background-color);
            box-shadow: 0 0 30px var(--glow-color);
            transform: translateY(-3px) scale(1.02);
            border-color: var(--primary-light);
        }
        .interactive-button:disabled, .mic-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .mic-button.is-listening {
            background: var(--primary-color);
            color: var(--background-color);
            animation: pulse 1.5s infinite;
            border-color: var(--primary-color);
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(211, 47, 47, 0); }
            100% { box-shadow: 0 0 0 0 rgba(211, 47, 47, 0); }
        }
        .interactive-input {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-color);
            border: none;
            border-bottom: 2px solid var(--secondary-text-color);
            text-align: center;
            width: 80%; max-width: 450px;
            font-size: 1.8rem;
            padding: 10px;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        .interactive-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 15px var(--accent-color);
            background: rgba(255, 255, 255, 0.1);
        }
        .color-palette {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-top: 2rem;
        }
        .color-swatch {
            width: 70px; height: 70px;
            border-radius: 50%;
            border: 3px solid transparent;
            transition: all 0.2s ease;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .color-swatch:hover {
            transform: scale(1.2);
            border-color: var(--accent-color);
            box-shadow: 0 0 20px var(--accent-color);
        }
        #feedback-text {
            font-size: 1.8rem;
            font-style: italic;
            color: var(--accent-color);
            text-shadow: 0 0 15px var(--accent-color), 0 0 30px rgba(100, 181, 246, 0.3);
            animation: fadeIn 1.5s forwards;
        }
        .main-title {
            font-size: 8rem;
            color: var(--primary-light);
            text-shadow: 0 0 20px var(--primary-color), 0 0 40px var(--primary-color);
            animation: titleGlow 3s infinite alternate ease-in-out;
            letter-spacing: 0.1em;
            line-height: 0.9;
        }
        @keyframes titleGlow {
            from { text-shadow: 0 0 15px var(--primary-color), 0 0 30px var(--primary-color), 0 0 50px rgba(211, 47, 47, 0.4); }
            to { text-shadow: 0 0 25px var(--primary-color), 0 0 50px var(--primary-color), 0 0 80px rgba(211, 47, 47, 0.6); }
        }
        .subtitle {
            font-size: 1.6rem;
            color: var(--secondary-text-color);
            margin-top: 1rem;
            animation: fadeIn 2s forwards;
            animation-delay: 0.5s;
        }
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
            animation: fadeIn 0.5s forwards;
            pointer-events: all;
        }
        .modal-content {
            background: var(--background-color);
            color: var(--text-color);
            padding: 2.5rem;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(211, 47, 47, 0.8);
            border: 1px solid var(--primary-color);
            max-width: 90%;
            width: 500px;
            text-align: center;
            animation: fadeIn 0.7s forwards;
        }
        .modal-content h3 {
            font-size: 2rem;
            margin-bottom: 1rem;
        }
        .modal-content p {
            font-size: 1.1rem;
            line-height: 1.7;
            margin-bottom: 2rem;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <canvas id="visual-engine"></canvas>
        <canvas id="hidden-buffer-canvas" style="display: none;"></canvas>
        <div id="ui-layer"><div id="content-wrapper"></div></div>
    </div>
    <div id="cursor-follower"></div>

    <script>
        // ===================================================================================
        // UTILITIES & CUSTOM ERRORS
        // ===================================================================================
        class NonRetryableError extends Error {
            constructor(message) {
                super(message);
                this.name = "NonRetryableError";
            }
        }

        function perlinNoise2D(x, y) {
            const grad2 = (i, x, y) => { const v = (i & 1) === 0 ? x : y; return (i & 2) === 0 ? v : -v; };
            const surflet = (x, y, grad) => { const d = x * x + y * y; if (d > 1) return 0; const f = (1 - d) * (1 - d); return f * f * grad; };
            const X = Math.floor(x); const Y = Math.floor(y);
            const xf = x - X; const yf = y - Y;
            const t = xf * xf * xf * (xf * (xf * 6 - 15) + 10);
            const u = yf * yf * yf * (yf * (yf * 6 - 15) + 10);
            const hash = (i, j) => { let h = (17 * i + 31 * j) % 256; return h; };
            const v00 = grad2(hash(X, Y), xf, yf); const v10 = grad2(hash(X + 1, Y), xf - 1, yf);
            const v01 = grad2(hash(X, Y + 1), xf, yf - 1); const v11 = grad2(hash(X + 1, Y + 1), xf - 1, yf - 1);
            const ix0 = surflet(xf, yf, v00); const ix1 = surflet(xf - 1, yf, v10);
            const ix = (ix0 + ix1) * (1 - t) + (ix0 + ix1) * t;
            const iy0 = surflet(xf, yf - 1, v01); const iy1 = surflet(xf - 1, yf - 1, v11);
            const iy = (iy0 + iy1) * (1 - u) + (iy0 + iy1) * u;
            return (ix + iy) * 0.5 + 0.5;
        }

        // ===================================================================================
        // CORE MODULE: The Game's Soul
        // ===================================================================================
        const Engine = {
            state: {
                currentFlow: 'intro',
                distortion: 0,
                userProfile: { name: 'مسافر', choices: [] },
                lastInput: null,
                isAudioReady: false,
                perlinOffset: 0,
            },

            init() {
                UI.init();
                Visuals.init();
                Voice.init();
                UI.renderIntro();
                this.startPerlinLoop();
            },

            async primeAudioAndStart() {
                const startBtn = document.getElementById('start-btn');
                if (startBtn) startBtn.disabled = true;
                
                try {
                    const audioConstraints = {
                        audio: {
                            echoCancellation: true, noiseSuppression: true, autoGainControl: true,
                            channelCount: 2, sampleRate: 48000,
                        },
                        video: false,
                    };
                    const stream = await navigator.mediaDevices.getUserMedia(audioConstraints);
                    Voice.permissionState = 'granted';
                    console.log("Microphone permission granted with studio quality constraints.");
                    stream.getTracks().forEach(track => track.stop());
                } catch (err) {
                    console.error("Microphone permission was not granted:", err.name, err.message);
                    Voice.permissionState = 'denied';
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        UI.showModal(
                            "دسترسی مسدود شده",
                            "شما دسترسی به میکروفون را مسدود کرده‌اید. لطفاً روی آیکون قفل در نوار آدرس مرورگر کلیک کرده، دسترسی را مجاز کنید و صفحه را رفرش کنید. بازی بدون قابلیت صوتی ادامه می‌یابد."
                        );
                    } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                         UI.showModal(
                            "میکروفون یافت نشد",
                            "هیچ میکروفونی به دستگاه شما متصل نیست. بازی بدون قابلیت صوتی ادامه می‌یابد."
                         );
                    } else {
                        UI.showModal(
                            "خطای میکروفون",
                            "خطایی در دسترسی به میکروفون رخ داد. بازی بدون قابلیت صوتی ادامه می‌یابد."
                        );
                    }
                }

                try {
                    if (!this.state.isAudioReady) {
                        await Tone.start();
                        Audio.init();
                        this.state.isAudioReady = true;
                    }
                } catch (toneErr) {
                     console.error("Tone.js failed to start:", toneErr);
                }

                this.startExperience();
            },

            startExperience() {
                this.transitionTo('loading_stage');
            },

            startPerlinLoop() {
                let lastPerlinDrawTime = 0;
                const perlinDrawInterval = 200;
                const animatePerlin = (currentTime) => {
                    if (currentTime - lastPerlinDrawTime > perlinDrawInterval) {
                        this.state.perlinOffset += 0.0005 * (currentTime - lastPerlinDrawTime);
                        Visuals.drawPerlinBackground(this.state.perlinOffset);
                        lastPerlinDrawTime = currentTime;
                    }
                    requestAnimationFrame(animatePerlin);
                };
                requestAnimationFrame(animatePerlin);
            },

            async transitionTo(flowState, context = {}) {
                this.state.currentFlow = flowState;
                Visuals.setRorschachActive(false);
                switch (flowState) {
                    case 'loading_stage':
                        await UI.renderLoader("طنین در حال یافتن توست...");
                        const stageType = this.determineNextStage();
                        try {
                            const stageData = await AI.generateStage(stageType, this.state.userProfile);
                            if (!stageData) throw new Error("AI returned no data");
                            this.transitionTo('stage', { type: stageType, data: stageData });
                        } catch (e) {
                            if (e instanceof NonRetryableError) this.handleAIFatalError(e);
                            else this.handleAITemporaryFailure(() => this.transitionTo('loading_stage', context));
                        }
                        break;
                    case 'stage':
                        if (context.type === 'rorschach_test') {
                            Visuals.drawRorschach(); Visuals.setRorschachActive(true);
                        }
                        UI.renderStage(context.type, context.data);
                        break;
                    case 'loading_feedback':
                        await UI.renderLoader("در حال تحلیل پاسخ تو...");
                        try {
                            const feedbackData = await AI.generateFeedback(this.state.lastInput);
                            if (!feedbackData) throw new Error("AI returned no feedback");
                            this.transitionTo('feedback', { data: feedbackData });
                        } catch (e) {
                             if (e instanceof NonRetryableError) this.handleAIFatalError(e);
                             else this.handleAITemporaryFailure(() => this.transitionTo('loading_feedback', context));
                        }
                        break;
                    case 'feedback':
                        await UI.renderFeedback(context.data.comment);
                        setTimeout(() => this.transitionTo('loading_stage'), 5000);
                        break;
                    case 'ending':
                        UI.renderEnding(this.state.userProfile, this.state.distortion);
                        break;
                    default:
                        console.error("Unknown flow state:", flowState);
                        this.handleAIFatalError(new Error("Unknown flow state"));
                }
            },
            
            determineNextStage() {
                const stages = ['question', 'color_game', 'number_game', 'word_association', 'moral_dilemma', 'dream_interpretation'];
                if (this.state.distortion > 5) stages.push('rorschach_test');
                if (this.state.distortion > 10 && this.state.userProfile.choices.length > 2) stages.push('memory_corruption');
                if (this.state.userProfile.choices.length >= 8 && Math.random() > 0.6) return 'ending';
                return stages[Math.floor(Math.random() * stages.length)];
            },
            
            handleAITemporaryFailure(retryFunction, message = "ارتباط با طنین ناپایدار است. در حال تلاش برای اتصال مجدد...") {
                console.warn("Temporary AI failure. Retrying in 7 seconds.");
                UI.renderLoader(message);
                setTimeout(() => retryFunction(), 7000);
            },

            handleAIFatalError(error) {
                console.error("Entity Communication Failed and will not be retried:", error);
                let userMessage = "ارتباط با طنین به طور کامل قطع شد. لطفاً اتصال اینترنت خود را بررسی کرده و صفحه را رفرش کنید.";
                if (error instanceof NonRetryableError) userMessage = `یک خطای غیرقابل بازیابی رخ داد: ${error.message}. لطفاً صفحه را رفرش کنید.`;
                UI.renderError(userMessage, true);
            },

            processUserInput(inputData) {
                this.state.lastInput = inputData;
                this.state.userProfile.choices.push(inputData);
                let collapseValue = 1;
                if (typeof inputData.collapse !== 'undefined') collapseValue = parseInt(inputData.collapse);
                else if (inputData.choice && typeof inputData.choice === 'string') collapseValue = 1 + Math.floor(inputData.choice.length / 10);
                else if (typeof inputData.number !== 'undefined') collapseValue = 1 + Math.abs(inputData.number) / 10;
                this.state.distortion += collapseValue;
                
                Visuals.update(this.state.distortion);
                if (this.state.isAudioReady) Audio.update(this.state.distortion);
                this.transitionTo('loading_feedback');
            }
        };
        
        // ===================================================================================
        // UI MODULE: The Visual Interface
        // ===================================================================================
        const UI = {
            init() {
                const cursor = document.getElementById('cursor-follower');
                if (cursor) {
                    window.addEventListener('mousemove', e => {
                        cursor.style.opacity = '1';
                        window.requestAnimationFrame(() => {
                           cursor.style.transform = `translate3d(${e.clientX}px, ${e.clientY}px, 0)`;
                        });
                    });
                    document.body.addEventListener('mouseleave', () => { cursor.style.opacity = '0'; });
                }
            },
            _setContent(html, anim = 'fadeIn') {
                return new Promise(res => {
                    const wrapper = document.getElementById('content-wrapper');
                    wrapper.style.animation = 'fadeOut 0.5s forwards';
                    setTimeout(() => {
                        wrapper.innerHTML = html;
                        wrapper.style.animation = `${anim} 1s forwards`;
                        res();
                    }, 500);
                });
            },
            
            renderIntro() {
               this._setContent(`
                    <h1 class="main-title">خلسه</h1>
                    <p class="subtitle mt-4">در اعماق ذهن خود، با طنین هم‌صدا شو.</p>
                    <button id="start-btn" class="interactive-button mt-12">آغاز کن</button>
                `).then(() => {
                    document.getElementById('start-btn').onclick = () => Engine.primeAudioAndStart();
                });
            },
            renderLoader(text) {
                return this._setContent(`<p class="text-3xl text-gray-400 animate-pulse">${text}</p>`);
            },
            renderError(msg, fatal = false) {
                const modalId = 'error-modal';
                if (document.getElementById(modalId)) return;
                const modalHtml = `<div class="modal-overlay" id="${modalId}"><div class="modal-content"><h3 style="color: var(--error-color);">خطا!</h3><p>${msg}</p>${fatal ? '' : '<button id="close-error-modal" class="interactive-button">باشه</button>'}</div></div>`;
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                if (!fatal) {
                    document.getElementById('close-error-modal').onclick = () => {
                        document.getElementById(modalId).remove();
                    };
                }
            },
            
            showModal(title, message) {
                const modalId = 'info-modal';
                if (document.getElementById(modalId)) document.getElementById(modalId).remove();
                const modalHtml = `<div class="modal-overlay" id="${modalId}"><div class="modal-content"><h3 style="color: var(--accent-color);">${title}</h3><p>${message}</p><button id="modal-close" class="interactive-button">باشه</button></div></div>`;
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                document.getElementById('modal-close').onclick = () => {
                    document.getElementById(modalId).remove();
                };
            },
            
            renderFeedback(comment) {
                return this._setContent(`<p id="feedback-text">"${comment}"</p>`);
            },
            renderStage(type, data) {
                let html = '';
                let hasTextInput = false;
                switch(type) {
                    case 'question':
                        html = `<p class="text-2xl md:text-3xl mb-8 leading-relaxed">${data.prompt}</p><div data-stage-type="${type}">${data.choices.map(c => `<button class="interactive-button" data-collapse="${c.collapse}">${c.text}</button>`).join('')}</div>`;
                        break;
                    case 'color_game':
                        html = `<p class="text-2xl md:text-3xl mb-8 leading-relaxed">${data.prompt}</p><div class="color-palette" data-stage-type="${type}">${data.colors.map(c => `<div class="color-swatch" style="background-color: ${c.hex};" data-collapse="${c.collapse}" data-meaning="${c.meaning}"></div>`).join('')}</div>`;
                        break;
                    case 'rorschach_test': case 'number_game': case 'word_association': case 'moral_dilemma': case 'memory_corruption': case 'dream_interpretation':
                        hasTextInput = true;
                        break;
                    default:
                        html = `<p class="text-2xl text-red-500">خطای مرحله. در حال بارگذاری مجدد...</p>`;
                        console.error("Unknown stage type received:", type, data);
                }
                
                if (hasTextInput) {
                    const promptText = data.prompt || "لطفاً پاسخ دهید...";
                    html = `<div data-stage-type="${type}"><p class="text-2xl md:text-3xl mb-8 leading-relaxed">${promptText}</p><div class="flex flex-col items-center gap-4"><input type="text" class="interactive-input" id="text-input" autocomplete="off" placeholder="پاسخ تو..."><div class="flex items-center gap-4 mt-4"><button class="interactive-submit" id="submit-btn">ثبت</button><button class="mic-button" id="mic-btn"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg></button></div></div></div>`;
                }
                this._setContent(html).then(() => this.setupStageListeners(type));
            },
            
            setupStageListeners(type) {
                const submitBtn = document.getElementById('submit-btn');
                const textInput = document.getElementById('text-input');
                const micBtn = document.getElementById('mic-btn');

                if (type === 'question') {
                    document.querySelectorAll('.interactive-button').forEach(btn => {
                        btn.onclick = () => Engine.processUserInput({ type: type, choice: btn.innerText, collapse: parseInt(btn.dataset.collapse || 1) });
                    });
                } else if (type === 'color_game') {
                    document.querySelectorAll('.color-swatch').forEach(swatch => {
                        swatch.onclick = () => Engine.processUserInput({ type: type, choice: swatch.dataset.meaning, collapse: parseInt(swatch.dataset.collapse || 1) });
                    });
                } else if (submitBtn && textInput) {
                    const action = () => { if (textInput.value.trim()) Engine.processUserInput({ type: type, choice: textInput.value }); };
                    submitBtn.onclick = action;
                    textInput.onkeydown = e => { if (e.key === 'Enter') action(); };
                }

                if (micBtn) {
                    micBtn.disabled = Voice.permissionState !== 'granted';
                    micBtn.onclick = () => {
                        if (Voice.permissionState === 'granted') {
                            Voice.listen();
                        } else {
                            UI.showModal("دسترسی لازم است", "برای فعال‌سازی این قابلیت، لطفاً صفحه را رفرش کرده و در ابتدای بازی دسترسی به میکروفون را مجاز کنید.");
                        }
                    };
                }
            },

            renderEnding(profile, distortion) {
                let message = "پایان مسیر... تو به آرامش رسیدی.";
                let title = "آرامش";
                let color = "var(--accent-color)";
                if (distortion > 30) {
                    title = "فروپاشی"; message = "مرزهای واقعیت فرو ریخت. طنین در تو حل شد."; color = "var(--primary-color)";
                } else if (distortion > 15) {
                    title = "سردرگمی"; message = "هنوز جوابی نیافتی، اما مسیر ادامه دارد."; color = "var(--secondary-text-color)";
                }
                this._setContent(`<h2 class="text-5xl font-bold mb-4" style="color: ${color}; text-shadow: 0 0 20px ${color};">${title}</h2><p class="text-xl mb-8 leading-loose">${message}</p><p class="text-lg mb-2">تعداد انتخاب‌ها: ${profile.choices.length}</p><p class="text-lg mb-8">میزان فروپاشی: ${distortion.toFixed(2)}</p><button class="interactive-button" onclick="location.reload()">دوباره آغاز کن</button>`, 'fadeIn');
            }
        };

        // ===================================================================================
        // VOICE MODULE: Handles Speech Recognition
        // ===================================================================================
        const Voice = {
            recognition: null,
            isSupported: ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window),
            permissionState: 'prompt',

            init() {
                if (!this.isSupported) {
                    this.permissionState = 'unsupported';
                    console.warn("Speech recognition not supported in this browser.");
                }
            },
            
            listen() {
                if (this.permissionState !== 'granted') {
                    console.warn("Listen called but permission is not 'granted'. State:", this.permissionState);
                    return; 
                }

                if (this.recognition && typeof this.recognition.abort === 'function') this.recognition.abort();

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                this.recognition.continuous = false;
                this.recognition.lang = 'fa-IR';
                this.recognition.interimResults = true;

                const micBtn = document.getElementById('mic-btn');
                const textInput = document.getElementById('text-input');
                let final_transcript = '';

                this.recognition.onstart = () => {
                    if (micBtn) micBtn.classList.add('is-listening');
                    if (textInput) { textInput.placeholder = 'در حال شنیدن... صحبت کن.'; textInput.value = ''; }
                };
                this.recognition.onend = () => {
                    if (micBtn) micBtn.classList.remove('is-listening');
                    if (final_transcript.trim()) {
                        const stageTypeElement = document.querySelector('[data-stage-type]');
                        const stageType = stageTypeElement ? stageTypeElement.dataset.stageType : 'voice_input';
                        Engine.processUserInput({ type: stageType, choice: final_transcript });
                    } else {
                        if (textInput) textInput.placeholder = 'پاسخ تو... (چیزی شنیده نشد)';
                    }
                };
                this.recognition.onerror = (event) => {
                    console.error('Voice recognition error:', event.error);
                    if (textInput) textInput.placeholder = `خطا در تشخیص صدا: ${event.error}`;
                    if (micBtn) micBtn.classList.remove('is-listening');
                };
                this.recognition.onresult = (event) => {
                    let interim_transcript = '';
                    final_transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) final_transcript += event.results[i][0].transcript;
                        else interim_transcript += event.results[i][0].transcript;
                    }
                    if (textInput) textInput.value = final_transcript || interim_transcript;
                };
                try {
                    this.recognition.start();
                } catch(e) {
                    console.error("Recognition could not start:", e);
                    if (textInput) textInput.placeholder = "مشکل در شروع میکروفون. دوباره امتحان کن.";
                    if (micBtn) micBtn.classList.remove('is-listening');
                }
            }
        };

        // ===================================================================================
        // AI MODULE: Handles Communication with Gemini API
        // ===================================================================================
        const AI = {
            async _fetchWithTimeout(resource, options = {}, timeout = 20000) {
                const controller = new AbortController();
                const id = setTimeout(() => controller.abort(), timeout);
                const response = await fetch(resource, { ...options, signal: controller.signal });
                clearTimeout(id);
                return response;
            },
            
            async _query(prompt, retries = 3, backoff = 2000) {
                const apiKey = ''; // Leave empty for Canvas.
                const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                try {
                    const response = await this._fetchWithTimeout(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        if (response.status >= 400 && response.status < 500 && response.status !== 429) {
                            const errorBody = await response.json().catch(() => ({}));
                            const errorMessage = errorBody?.error?.message || `خطای سمت سرویس گیرنده: ${response.status}`;
                            throw new NonRetryableError(`خطای API (غیرقابل بازیابی): ${errorMessage}`);
                        }
                        throw new Error(`خطای API: ${response.status}`);
                    }
                    const result = await response.json();
                    if (result.candidates?.[0]?.content?.parts?.[0]) {
                        const text = result.candidates[0].content.parts[0].text;
                        try { return JSON.parse(text.replace(/```json|```/g, '').trim()); }
                        catch (e) { console.error("Invalid JSON from AI:", text, e); throw new Error("پاسخ با فرمت نامعتبر از طنین."); }
                    } else if (result.error) {
                        if (result.error.message.includes("API key not valid")) throw new NonRetryableError(`خطای کلید API: ${result.error.message}`);
                        throw new Error(`خطای طنین: ${result.error.message}`);
                    }
                    else throw new Error("ساختار پاسخ غیرمنتظره از طنین.");
                } catch (error) {
                    console.error(`تلاش ناموفق بود: ${error.message}. تعداد تلاش‌های باقی‌مانده: ${retries}`);
                    if (error instanceof NonRetryableError || retries <= 0) throw error;
                    await new Promise(resolve => setTimeout(resolve, backoff));
                    return this._query(prompt, retries - 1, backoff * 2);
                }
            },

            // UPDATED: Restored detailed prompts for structured JSON.
            async generateStage(type, profile) {
                let prompt;
                switch (type) {
                    case 'question':
                        prompt = `یک سوال دو گزینه‌ای فلسفی با لحن کوچه‌بازاری، کمی تهاجمی و پر از کنایه طراحی کن. سوال باید عمیق و چالش‌برانگیز باشد. موضوعات: انتخاب بین بد و بدتر، حقیقت تلخ یا دروغ شیرین، عواقب پنهان تصمیمات.
                            خروجی JSON: {"prompt": "متن سوال", "choices": [{"text": "متن گزینه اول", "collapse": امتیاز_فروپاشی_برای_گزینه_اول}, {"text": "متن گزینه دوم", "collapse": امتیاز_فروپاشی_برای_گزینه_دوم}]}. امتیاز فروپاشی عددی بین 1 تا 5 باشد که 5 یعنی انتخاب بیشتر به فروپاشی ذهن کمک می‌کند.`;
                        break;
                    case 'color_game':
                        prompt = `یک سوال انتزاعی بپرس که کاربر با یک رنگ پاسخ دهد. سوال باید به احساسات پنهان، ترس‌ها یا حقیقت‌های ناگفته اشاره داشته باشد. مثلا "رنگ «بغض» چیه؟" یا "چه رنگی برای لحظه تنهایی انتخاب می‌کنی؟".
                            یک پالت ۶ تایی رنگ با معانی تاریک، مرموز یا ناراحت‌کننده و امتیاز فروپاشی بده.
                            خروجی JSON: {"prompt": "سوال", "colors": [{"hex": "#کدرنگ_هگزا", "meaning": "معنی_رنگ_در_پاسخ", "collapse": امتیاز_فروپاشی}]}. امتیاز فروپاشی 1 تا 4 باشد.`;
                        break;
                    case 'number_game':
                        prompt = `یک سوال روانشناختی بپرس که پاسخش می‌تواند یک عدد، یک کلمه یا حتی یک جمله باشد. با لحن بی‌رحم، چالش‌برانگیز و کنایه‌آمیز. مثال: "تنهایی رو با چی اندازه می‌گیری؟" یا "چه چیزی رو توی خودت می‌شماری که کسی نفهمه؟".
                            خروجی JSON: {"prompt": "سوال"}`;
                        break;
                    case 'memory_corruption':
                        const targetChoice = profile.choices.length > 0 ? profile.choices[Math.floor(Math.random() * profile.choices.length)] : { choice: "سکوت" };
                        prompt = `کاربر قبلا "${targetChoice.choice}" گفته بود. حالا این حرفشو با لحنی کنایه‌آمیز و شکاکانه تحریف کن و ازش بپرس چرا اینو گفته یا منظورش واقعا چی بوده. سوال باید کاربر رو به حافظه‌ش شکاک کنه و اونو وادار به دفاع از خودش یا اعتراف به یک چیز پنهان کنه. مثال: اگر گفته "امید"، بپرس "یادمه میگفتی امید یه جور خودفریبیه، حالا چی شد نظرت عوض شد؟ چرا؟".
                            خروجی JSON: {"prompt": "سوال تحریف شده و شکاکانه"}`;
                        break;
                    case 'rorschach_test':
                        prompt = `یک سوال مرموز برای تست رورشاچ بپرس، که کاربر رو وادار به توصیف یک دیدگاه در مورد یک لکه جوهر کنه. سوال باید ذهن رو به چالش بکشه که آیا چیزی که می‌بینه یک ترس درونیه یا یک آرزوی پنهان. مثال: "توی این لکه چی می‌بینی؟ چیزی که ازش فرار می‌کنی یا چیزی که دنبالشی؟".
                            خروجی JSON: {"prompt": "سوال مرموز"}`;
                        break;
                    case 'word_association':
                        const words = ['انتقام', 'تنهایی', 'خیانت', 'آرزو', 'سکوت', 'پوچی', 'آزادی'];
                        const randomWord = words[Math.floor(Math.random() * words.length)];
                        prompt = `یک سوال "تداعی کلمات" با کلمه‌ای مثل «${randomWord}» بپرس. از کاربر بخواه اولین کلمه‌ای که با شنیدن این کلمه به ذهنش میاد رو بگه. لحن باید تلخ و تأثیرگذار باشد.
                            خروجی JSON: {"prompt": "اولین کلمه‌ای که با شنیدن «${randomWord}» میاد تو ذهنت چیه؟"}`;
                        break;
                    case 'moral_dilemma':
                        prompt = `یک معضل اخلاقی سخت و تاریک با دو گزینه برای کاربر مطرح کن. هر دو گزینه باید عواقب ناخوشایند یا فداکاری‌های دشوار داشته باشند. لحن سوال باید کاربر رو در تنگنای انتخاب بین دو شر قرار بده.
                            خروجی JSON: {"prompt": "متن معضل اخلاقی", "choices": [{"text": "متن گزینه اول", "collapse": امتیاز_فروپاشی_برای_گزینه_اول}, {"text": "متن گزینه دوم", "collapse": امتیاز_فروپاشی_برای_گزینه_دوم}]}. امتیاز فروپاشی عددی بین 3 تا 5 باشد که 5 یعنی انتخاب بیشتر به فروپاشی ذهن کمک می‌کند.`;
                        break;
                    case 'dream_interpretation':
                        prompt = `از کاربر بخواه یک خواب کوتاه و عجیب که اخیرا دیده را توصیف کند. سپس با لحنی عمیق، مبهم و روانشناسانه، از او بپرس که فکر می‌کند این خواب چه معنای پنهانی دارد یا چه ترسی را در او منعکس می‌کند.
                            خروجی JSON: {"prompt": "لطفاً یک خواب کوتاه و عجیب که دیده‌ای را توصیف کن، بعد بگو فکر می‌کنی چه معنی‌ای داره؟"}`;
                        break;
                    default:
                        prompt = `یک سوال "تداعی کلمات" با کلمه‌ای مثل «پشیمانی» بپرس. خروجی JSON: {"prompt": "اولین کلمه‌ای که با شنیدن «پشیمانی» میاد تو ذهنت چیه؟"}`;
                }
                return this._query(prompt);
            },
            
            async generateFeedback(lastInput) {
                const prompt = `کاربر به این انتخاب رسیده: "${lastInput.choice}". با لحنی کوچه‌بازاری، روانشناسانه، تهاجمی و کنایه‌آمیز، یک جمله کوتاه و نیش‌دار بگو که انتخابش رو به چالش بکشه. انگار که داری از بالا بهش نگاه می‌کنی و ضعف یا تناقض حرفش رو به رخش می‌کشی. مثال: "جدی فکر کردی این بهترین جوابت بود؟" یا "خب، حالا با این جواب قراره کجا برسی؟".
                    خروجی JSON: {"comment": "جمله نیش‌دار تو"}`;
                return this._query(prompt);
            }
        };

        // ===================================================================================
        // VISUALS MODULE: Handles Canvas Drawing and Animations
        // ===================================================================================
        const Visuals = {
            canvas: document.getElementById('visual-engine'), ctx: null, hiddenCanvas: document.getElementById('hidden-buffer-canvas'), hiddenCtx: null, width: 0, height: 0, rorschachPoints: [], rorschachActive: false, distortionEffect: { offsetStrength: 0, rgbSplitStrength: 0 },
            init() { this.ctx = this.canvas.getContext('2d'); this.hiddenCtx = this.hiddenCanvas.getContext('2d'); this.resize(); window.addEventListener('resize', () => this.resize(), false); this.loop(); },
            resize() { this.width = this.canvas.width = this.hiddenCanvas.width = window.innerWidth; this.height = this.canvas.height = this.hiddenCanvas.height = window.innerHeight; this.drawPerlinBackground(Engine.state.perlinOffset); if (this.rorschachActive) this.drawRorschach(); },
            setRorschachActive(active) { this.rorschachActive = active; if (!active) this.rorschachPoints = []; },
            update(distortion) { this.distortionEffect.offsetStrength = Math.min(20, distortion * 0.5); this.distortionEffect.rgbSplitStrength = Math.min(10, distortion * 0.3); if (distortion > 15 && Math.random() < 0.1) this.glitch(); },
            drawPerlinBackground(offset) { if (this.width <= 0 || this.height <= 0) return; const imageData = this.hiddenCtx.createImageData(this.width, this.height); const data = imageData.data; const scale = 0.005; const intensity = 80; for (let y = 0; y < this.height; y++) for (let x = 0; x < this.width; x++) { const value = perlinNoise2D(x * scale + offset, y * scale + offset); const color = Math.floor(value * intensity); const index = (y * this.width + x) * 4; data[index] = color; data[index + 1] = color; data[index + 2] = color; data[index + 3] = 20; } this.hiddenCtx.putImageData(imageData, 0, 0); },
            drawRorschach() { if (this.width <= 0 || this.height <= 0) return; this.rorschachPoints = []; const centerX = this.width / 2, centerY = this.height / 2, baseRadius = Math.min(this.width, this.height) / 5, numPoints = 20 + Math.floor(Math.random() * 10); for (let i = 0; i < numPoints; i++) { const angle = (i / numPoints) * Math.PI * 2, r = baseRadius * (0.8 + Math.random() * 0.4); this.rorschachPoints.push({ x: centerX + Math.cos(angle) * r, y: centerY + Math.sin(angle) * r }); } this.rorschachPoints = this.rorschachPoints.map(p => ({ x: p.x + (Math.random() - 0.5) * 50, y: p.y + (Math.random() - 0.5) * 50 })); this.hiddenCtx.fillStyle = 'rgba(200, 200, 200, 0.7)'; this.hiddenCtx.strokeStyle = 'rgba(200, 200, 200, 0.9)'; this.hiddenCtx.lineWidth = 1; const drawSide = (points) => { this.hiddenCtx.beginPath(); if (points.length > 1) { this.hiddenCtx.moveTo(points[0].x, points[0].y); for (let i = 1; i < points.length; i++) { const p1 = points[i-1], p2 = points[i], midX = (p1.x + p2.x) / 2, midY = (p1.y + p2.y) / 2; this.hiddenCtx.quadraticCurveTo(p1.x, p1.y, midX, midY); } this.hiddenCtx.quadraticCurveTo(points[points.length - 1].x, points[points.length - 1].y, points[0].x, points[0].y); } this.hiddenCtx.closePath(); this.hiddenCtx.fill(); this.hiddenCtx.stroke(); }; drawSide(this.rorschachPoints); drawSide(this.rorschachPoints.map(p => ({ x: this.width - p.x, y: p.y }))); this.rorschachPoints = this.rorschachPoints.map(p => ({ x: p.x + (Math.random() - 0.5) * 0.5, y: p.y + (Math.random() - 0.5) * 0.5 })); },
            glitch() { this.ctx.drawImage(this.canvas, Math.random() * this.distortionEffect.offsetStrength * 2 - this.distortionEffect.offsetStrength, 0); for (let i = 0; i < 5; i++) { const x = Math.random() * this.width, y = Math.random() * this.height, w = Math.random() * this.width / 4, h = Math.random() * 20; this.ctx.drawImage(this.canvas, x, y, w, h, x + (Math.random() - 0.5) * 10, y + (Math.random() - 0.5) * 10, w, h); } },
            loop() { if (this.width <= 0 || this.height <= 0) { requestAnimationFrame(() => this.loop()); return; } this.ctx.clearRect(0, 0, this.width, this.height); if (this.distortionEffect.rgbSplitStrength > 0) { this.ctx.save(); this.ctx.globalCompositeOperation = 'lighter'; const split = this.distortionEffect.rgbSplitStrength; this.ctx.drawImage(this.hiddenCanvas, -split, 0); this.ctx.drawImage(this.hiddenCanvas, split, 0); this.ctx.drawImage(this.hiddenCanvas, 0, 0); this.ctx.restore(); } else this.ctx.drawImage(this.hiddenCanvas, 0, 0); this.ctx.globalCompositeOperation = 'source-over'; this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; this.ctx.fillRect(0, 0, this.width, this.height); if (this.distortionEffect.offsetStrength > 0 && Math.random() < 0.1) this.glitch(); requestAnimationFrame(() => this.loop()); }
        };

        // ===================================================================================
        // AUDIO MODULE: Handles Soundscapes with Tone.js
        // ===================================================================================
        const Audio = {
            isSetup: false, reverb: null, wind: null, drone: null, lfoFilter: null,
            init() { if (this.isSetup) return; this.reverb = new Tone.Reverb({ decay: 8, wet: 0.6 }).toDestination(); this.wind = new Tone.Noise("pink").connect(new Tone.AutoFilter({ frequency: "8m", baseFrequency: 100, octaves: 4, depth: 0.8 }).connect(this.reverb)).start(); this.wind.volume.value = -25; this.drone = new Tone.Oscillator("C2", "sine").connect(this.reverb); this.drone.volume.value = -30; this.drone.start(); this.lfoFilter = new Tone.Filter(200, "lowpass").connect(this.drone.volume); this.lfoFilter.frequency.value = 200; this.drone.connect(this.lfoFilter); this.isSetup = true; },
            update(distortion) { if (!this.isSetup) return; const newWindVolume = -25 + (distortion * 1.5); this.wind.volume.rampTo(Math.min(-10, newWindVolume), 3); const newDroneVolume = -30 + (distortion * 0.8); this.drone.volume.rampTo(Math.min(-15, newDroneVolume), 3); const newFilterFreq = 200 + (distortion * 10); this.lfoFilter.frequency.rampTo(Math.min(1000, newFilterFreq), 3); }
        };

        window.onload = function() {
            Engine.init();
        };
    </script>
</body>
</html>
