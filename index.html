<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>خلسه ۲.۱</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #e53935; /* A slightly more intense red */
            --background-color: #000;
            --text-color: #b0bec5;
            --accent-color: #1976d2; /* For feedback and special highlights */
        }
        html, body {
            width: 100%; height: 100%; margin: 0; padding: 0;
            background: var(--background-color);
            cursor: none; font-family: 'Vazirmatn', sans-serif;
            user-select: none; overflow: hidden;
        }
        #app-container, #visual-engine, #ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
        }
        #visual-engine { z-index: 1; }
        #ui-layer { z-index: 10; display: flex; justify-content: center; align-items: center; text-align: center; padding: 1rem; color: var(--text-color); pointer-events: none; }
        #ui-layer > * { pointer-events: auto; }
        /* CHANGE: Removed backdrop-filter for clarity */
        #content-wrapper { 
            width: 95%; max-width: 800px; 
            background: rgba(0,0,0,0.35); /* Kept a subtle background for readability */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem; 
            padding: 2rem 1rem; 
        }
        #cursor-follower {
            position: fixed; width: 24px; height: 24px;
            border-radius: 50%; background: var(--primary-color);
            pointer-events: none; z-index: 9999; mix-blend-mode: difference;
            transition: transform 0.1s ease-out, opacity 0.3s ease;
            will-change: transform; opacity: 0; box-shadow: 0 0 15px var(--primary-color);
        }
        @keyframes fadeIn { from { opacity: 0; filter: blur(5px); transform: translateY(15px) scale(0.98); } to { opacity: 1; filter: blur(0); transform: translateY(0) scale(1); } }
        @keyframes fadeOut { from { opacity: 1; filter: blur(0); transform: translateY(0) scale(1); } to { opacity: 0; filter: blur(5px); transform: translateY(-15px) scale(0.98); } }
        .interactive-button, .interactive-submit, .mic-button {
            background: transparent; border: 2px solid var(--primary-color); color: var(--primary-color);
            padding: 12px 24px; font-size: 1.1rem; transition: all 0.25s; margin: 8px;
            display: inline-flex; align-items: center; justify-content: center; border-radius: 8px; font-weight: 700;
        }
        .interactive-button:hover:not(:disabled), .interactive-submit:hover, .mic-button:hover:not(:disabled) { background: var(--primary-color); color: var(--background-color); box-shadow: 0 0 25px var(--primary-color); transform: scale(1.05); }
        .interactive-button:disabled, .mic-button:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; background: transparent; }
        .mic-button.is-listening { background: var(--primary-color); color: var(--background-color); animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(229, 57, 53, 0.8); } 70% { box-shadow: 0 0 0 25px rgba(229, 57, 53, 0); } 100% { box-shadow: 0 0 0 0 rgba(229, 57, 53, 0); } }
        .interactive-input {
            background: transparent; color: #fff; border: none; border-bottom: 2px solid var(--text-color);
            text-align: center; width: 90%; max-width: 500px; font-size: 2.5rem; padding: 10px; font-weight: 900;
        }
        .interactive-input:focus { outline: none; border-color: var(--primary-color); }
        .color-palette { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-top: 2rem; }
        .color-swatch { width: 70px; height: 70px; border-radius: 50%; border: 3px solid transparent; transition: all 0.2s; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .color-swatch:hover { transform: scale(1.15); border-color: #fff; }
        #feedback-text { font-size: 1.8rem; font-style: italic; color: var(--accent-color); text-shadow: 0 0 15px var(--accent-color); }
        .loader-text { font-size: 1.5rem; text-shadow: 0 0 10px var(--text-color); animation: subtlePulse 2s ease-in-out infinite; }
        @keyframes subtlePulse { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; } }
        #image-display-container { width: 100%; height: 100%; display: none; justify-content: center; align-items: center; background: rgba(0,0,0,0.8); }
        #generated-image { max-width: 80%; max-height: 80%; border-radius: 1rem; box-shadow: 0 0 50px var(--primary-color); }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="visual-engine"></div>
        <div id="ui-layer">
            <div id="content-wrapper" style="opacity: 0;"></div>
        </div>
    </div>
    <div id="cursor-follower"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';

        // ===================================================================================
        // UTILITIES & CUSTOM ERRORS
        // ===================================================================================
        class NonRetryableError extends Error {
            constructor(message) { super(message); this.name = "NonRetryableError"; }
        }

        // ===================================================================================
        // CORE MODULE: The Experience's Soul
        // ===================================================================================
        const Engine = {
            state: {
                currentFlow: 'intro',
                distortion: 0,
                userProfile: { name: 'مسافر', choices: [] },
                lastInput: null,
                isAudioReady: false,
                stageHistory: [],
            },

            init() {
                UI.init();
                Visuals.init(document.getElementById('visual-engine'));
                Voice.init();
                UI.renderIntro();
            },

            async primeAudioAndStart() {
                try {
                    if (!this.state.isAudioReady) {
                        await Tone.start();
                        Audio.init();
                        this.state.isAudioReady = true;
                    }
                    this.startExperience();
                } catch(e) {
                    console.error("Audio Context Failed To Start:", e);
                    UI.renderError("خطا در زمینه صوتی. تجربه بدون صدا ادامه می‌یابد.");
                    setTimeout(() => this.startExperience(), 2000);
                }
            },

            startExperience() {
                this.transitionTo('loading_stage');
            },

            async transitionTo(flowState, context = {}) {
                this.state.currentFlow = flowState;
                switch (flowState) {
                    case 'loading_stage':
                        await UI.renderLoader("طنین در حال یافتن توست...");
                        const stageType = this.determineNextStage();
                        this.state.stageHistory.push(stageType);
                        try {
                            const stageData = await AI.generateStage(stageType, this.state.userProfile);
                            this.transitionTo('stage', { type: stageType, data: stageData });
                        } catch (e) {
                            this.handleAIFailure(e, () => this.transitionTo('loading_stage', context));
                        }
                        break;

                    case 'stage':
                        UI.renderStage(context.type, context.data);
                        break;
                    
                    case 'loading_image':
                        await UI.renderLoader("در حال ترسیم پژواک ذهن تو...");
                        try {
                            const imageData = await AI.generateImage(context.prompt);
                            this.transitionTo('image_display', { imageData: imageData, prompt: context.prompt });
                        } catch (e) {
                            this.handleAIFailure(e, () => this.transitionTo('loading_stage'));
                        }
                        break;

                    case 'image_display':
                        await UI.renderImageStage(context.imageData, context.prompt);
                        break;

                    case 'loading_feedback':
                        await UI.renderLoader("در حال تحلیل پاسخ تو...");
                        try {
                            const feedbackData = await AI.generateFeedback(this.state.lastInput, this.state.userProfile);
                            this.transitionTo('feedback', { data: feedbackData });
                        } catch (e) {
                            this.handleAIFailure(e, () => this.transitionTo('loading_feedback', context));
                        }
                        break;

                    case 'feedback':
                        await UI.renderFeedback(context.data.comment);
                        setTimeout(() => this.transitionTo('loading_stage'), 6000); // Increased delay
                        break;

                    default:
                        this.handleAIFatalError(new Error(`Unknown flow state: ${flowState}`));
                }
            },
            
            determineNextStage() {
                const stages = ['question', 'color_game', 'word_association', 'moral_dilemma', 'number_game'];
                // NEW: Added new intense stages with distortion gates
                if (this.state.distortion > 3) stages.push('image_creation');
                if (this.state.distortion > 5) stages.push('logical_fallacy');
                if (this.state.distortion > 7 && this.state.userProfile.choices.length > 2) stages.push('memory_corruption');
                if (this.state.distortion > 9 && this.state.userProfile.choices.length > 1) stages.push('echo_chamber');
                
                let availableStages = stages.filter(s => !this.state.stageHistory.slice(-2).includes(s));
                if (availableStages.length === 0) availableStages = stages;

                return availableStages[Math.floor(Math.random() * availableStages.length)];
            },

            handleAIFailure(error, retryFunction) {
                if (error instanceof NonRetryableError) {
                    this.handleAIFatalError(error);
                } else {
                    this.handleAITemporaryFailure(retryFunction);
                }
            },
            
            handleAITemporaryFailure(retryFunction) {
                console.warn("Temporary AI failure. Retrying in 8 seconds.");
                UI.renderLoader("ارتباط با طنین ناپایدار است. تلاش مجدد...");
                setTimeout(retryFunction, 8000);
            },

            handleAIFatalError(error) {
                console.error("Fatal AI Error:", error);
                let msg = `ارتباط با طنین قطع شد: ${error.message}. لطفا صفحه را بازنشانی کنید.`;
                UI.renderError(msg);
                Visuals.setPanicMode(true);
                Audio.setPanicMode(true);
            },

            processUserInput(inputData) {
                this.state.lastInput = inputData;
                this.state.userProfile.choices.push(inputData);
                // Tweak: Faster distortion ramp-up
                const collapseAmount = inputData.collapse || (inputData.choice.length / 8) + 1.5;
                this.state.distortion += collapseAmount;

                Visuals.update({ distortion: this.state.distortion });
                if (this.state.isAudioReady) Audio.update({ distortion: this.state.distortion });

                if (inputData.type === 'image_creation') {
                    this.transitionTo('loading_image', { prompt: inputData.choice });
                } else {
                    this.transitionTo('loading_feedback');
                }
            }
        };
        
        // ===================================================================================
        // UI MODULE: The Visual Interface
        // ===================================================================================
        const UI = {
            init() {
                const cursor = document.getElementById('cursor-follower');
                if (cursor) {
                    window.addEventListener('mousemove', e => {
                        cursor.style.opacity = '1';
                        cursor.style.transform = `translate(${e.clientX}px, ${e.clientY}px)`;
                    });
                    document.body.addEventListener('mouseleave', () => { cursor.style.opacity = '0'; });
                }
            },
            _setContent(html, anim = 'fadeIn') {
                return new Promise(resolve => {
                    const wrapper = document.getElementById('content-wrapper');
                    const currentAnim = wrapper.style.animation;
                    if (currentAnim.includes('fadeIn')) {
                        wrapper.style.animation = 'fadeOut 0.5s forwards';
                    }
                    setTimeout(() => {
                        wrapper.innerHTML = html;
                        wrapper.style.animation = `${anim} 1s forwards`;
                        resolve();
                    }, currentAnim.includes('fadeIn') ? 500 : 0);
                });
            },
            
            renderIntro() {
               this._setContent(`
                    <h1 class="text-7xl font-black text-white">خلسه</h1>
                    <p class="mt-4 text-gray-400 text-xl">طنین یک ذهن در انتظار توست.</p>
                    <button id="start-btn" class="interactive-button mt-12 text-2xl">آغــاز</button>
                `).then(() => {
                    document.getElementById('start-btn').onclick = () => Engine.primeAudioAndStart();
                });
            },
            renderLoader(text) { return this._setContent(`<p class="loader-text">${text}</p>`); },
            renderError(msg) { return this._setContent(`<p class="text-2xl text-red-400">${msg}</p>`); },
            renderFeedback(comment) { return this._setContent(`<p id="feedback-text">"${comment}"</p>`); },

            async renderImageStage(base64Image, prompt) {
                const html = `
                    <div id="image-container" class="flex flex-col items-center animate-fadeIn">
                        <img id="generated-image" src="${base64Image}" alt="تصویر ساخته شده بر اساس: ${prompt}" class="mb-8 max-w-[80%] md:max-w-[512px] max-h-[512px] rounded-lg shadow-2xl shadow-red-900/50"/>
                        <p class="text-2xl md:text-3xl mb-8">این تصویر چه حسی به تو می‌دهد؟</p>
                        <div class="flex flex-col items-center gap-4">
                            <input type="text" class="interactive-input" id="text-input" autocomplete="off" placeholder="احساس خود را بنویس...">
                            <div class="flex items-center gap-4 mt-4">
                                <button class="interactive-submit" id="submit-btn">ثبت</button>
                                <button class="mic-button" id="mic-btn">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                 await this._setContent(html, 'fadeIn');
                 this.setupStageListeners('image_feedback', prompt);
            },

            renderStage(type, data) {
                let html = '';
                let isTextInput = false;
                switch(type) {
                    case 'question':
                    case 'logical_fallacy': // New stage uses the same template
                    case 'echo_chamber':    // New stage uses the same template
                        html = `<p class="text-2xl md:text-3xl mb-8">${data.prompt}</p><div class="flex flex-wrap justify-center" data-stage-type="${type}">${data.choices.map(c => `<button class="interactive-button" data-collapse="${c.collapse}">${c.text}</button>`).join('')}</div>`;
                        break;
                    case 'color_game':
                        html = `<p class="text-2xl md:text-3xl mb-8">${data.prompt}</p><div class="color-palette" data-stage-type="${type}">${data.colors.map(c => `<div class="color-swatch" style="background-color: ${c.hex};" data-collapse="${c.collapse}" data-meaning="${c.meaning}"></div>`).join('')}</div>`;
                        break;
                    case 'image_creation':
                    case 'memory_corruption':
                    case 'number_game':
                    case 'word_association':
                    case 'moral_dilemma':
                        isTextInput = true;
                        break;
                    default:
                         html = `<p class="text-2xl text-red-500">خطای مرحله. در حال بارگذاری مجدد...</p>`;
                         console.error("Unknown stage type received:", type, data);
                         setTimeout(() => Engine.transitionTo('loading_stage'), 2000);
                }
                
                if (isTextInput) {
                    const promptText = data.prompt || "پاسخ بده...";
                    html = `<div data-stage-type="${type}">
                                <p class="text-2xl md:text-3xl mb-8">${promptText}</p>
                                <div class="flex flex-col items-center gap-4">
                                    <input type="text" class="interactive-input" id="text-input" autocomplete="off" placeholder="پاسخ تو...">
                                    <div class="flex items-center gap-4 mt-4">
                                        <button class="interactive-submit" id="submit-btn">ثبت</button>
                                        <button class="mic-button" id="mic-btn">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                                        </button>
                                    </div>
                                </div>
                            </div>`;
                }
                this._setContent(html).then(() => this.setupStageListeners(type));
            },
            
            setupStageListeners(type, contextPrompt = '') {
                const submitBtn = document.getElementById('submit-btn');
                const textInput = document.getElementById('text-input');
                const micBtn = document.getElementById('mic-btn');

                const processText = () => {
                    if (textInput && textInput.value.trim()) {
                         const stageType = type === 'image_feedback' ? `image_feedback_on_${contextPrompt}` : type;
                         const collapse = 1.5 + Math.floor(textInput.value.length / 8);
                         Engine.processUserInput({ type: stageType, choice: textInput.value, collapse: collapse });
                    }
                };
                
                if (submitBtn && textInput) {
                    submitBtn.onclick = processText;
                    textInput.onkeydown = e => { if (e.key === 'Enter') processText(); };
                }

                if (type === 'question' || type === 'logical_fallacy' || type === 'echo_chamber') {
                    document.querySelectorAll('.interactive-button').forEach(btn => {
                        btn.onclick = () => Engine.processUserInput({ type, choice: btn.innerText, collapse: parseInt(btn.dataset.collapse || 2) });
                    });
                } else if (type === 'color_game') {
                     document.querySelectorAll('.color-swatch').forEach(swatch => {
                        swatch.onclick = () => Engine.processUserInput({ type, choice: swatch.dataset.meaning, collapse: parseInt(swatch.dataset.collapse || 2) });
                    });
                }

                if (micBtn) {
                    micBtn.onclick = () => Voice.requestAndListen(processText);
                }
            }
        };

        // ===================================================================================
        // VOICE MODULE: Handles Speech Recognition
        // ===================================================================================
        const Voice = {
            recognition: null,
            isSupported: ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window),
            
            init() { /* No immediate setup needed */ },

            async requestAndListen(submitCallback) {
                const micBtn = document.getElementById('mic-btn');
                const textInput = document.getElementById('text-input');
                if (!this.isSupported) {
                    if(textInput) textInput.placeholder = "گفتار پشتیبانی نمی‌شود.";
                    if(micBtn) micBtn.disabled = true;
                    return;
                }
                if (micBtn) micBtn.disabled = true;
                
                try {
                    await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.listen(submitCallback);
                } catch (err) {
                    console.error("Microphone permission denied:", err);
                    if (textInput) textInput.placeholder = "دسترسی به میکروفون لازم است.";
                } finally {
                     if (micBtn) micBtn.disabled = false;
                }
            },

            listen(submitCallback) {
                if (this.recognition && this.recognition.abort) this.recognition.abort();

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                this.recognition.continuous = false;
                this.recognition.lang = 'fa-IR';
                this.recognition.interimResults = true;
                
                const micBtn = document.getElementById('mic-btn');
                const textInput = document.getElementById('text-input');
                const submitBtn = document.getElementById('submit-btn');
                let final_transcript = '';

                this.recognition.onstart = () => { 
                    micBtn.classList.add('is-listening'); 
                    textInput.placeholder = 'در حال شنیدن...';
                    if(submitBtn) submitBtn.disabled = true; // FIX: Disable submit btn during listening
                };
                this.recognition.onend = () => {
                    micBtn.classList.remove('is-listening');
                    if(submitBtn) submitBtn.disabled = false; // FIX: Re-enable submit btn
                    if (final_transcript.trim()) {
                       textInput.value = final_transcript;
                       submitCallback();
                    } else { textInput.placeholder = 'پاسخ تو...'; }
                };
                this.recognition.onerror = (event) => { console.error('Voice recognition error:', event.error); textInput.placeholder = `خطا: ${event.error}`; };
                this.recognition.onresult = (event) => {
                    let interim_transcript = '';
                    final_transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) final_transcript += event.results[i][0].transcript;
                        else interim_transcript += event.results[i][0].transcript;
                    }
                    textInput.value = final_transcript || interim_transcript;
                };
                try { this.recognition.start(); } catch(e) { console.error("Recognition couldn't start:", e); }
            }
        };

        // ===================================================================================
        // AI MODULE: The Entity's Voice
        // ===================================================================================
        const AI = {
            async _fetchWithTimeout(resource, options = {}, timeout = 20000) {
                 const controller = new AbortController();
                 const id = setTimeout(() => controller.abort(), timeout);
                 const response = await fetch(resource, { ...options, signal: controller.signal });
                 clearTimeout(id);
                 return response;
            },
            
            async _query(prompt, retries = 3, backoff = 3000) {
                const apiKey = ""; // API Key will be injected by the environment.
                const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                try {
                    const response = await this._fetchWithTimeout(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        if (response.status >= 400 && response.status < 500 && response.status !== 429) {
                            const errorBody = await response.json().catch(() => ({}));
                            throw new NonRetryableError(errorBody?.error?.message || `Error ${response.status}`);
                        }
                        throw new Error(`API Error: ${response.status}`);
                    }
                    const result = await response.json();
                    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                        const text = result.candidates[0].content.parts[0].text;
                        try { return JSON.parse(text.replace(/```json|```/g, '').trim()); }
                        catch (e) { throw new Error("پاسخ با فرمت نامعتبر از طنین."); }
                    } else if (result.promptFeedback?.blockReason) {
                         throw new NonRetryableError(`Blocked: ${result.promptFeedback.blockReason}`);
                    } else { throw new Error("ساختار پاسخ غیرمنتظره."); }
                } catch (error) {
                    if (error instanceof NonRetryableError || retries <= 0) throw error;
                    await new Promise(resolve => setTimeout(resolve, backoff));
                    return this._query(prompt, retries - 1, backoff * 1.5);
                }
            },

            async generateImage(prompt) {
                const apiKey = "";
                const imageGenPrompt = `Create a surreal, abstract, dark, atmospheric, cinematic artwork representing the concept of "${prompt}". Use a palette of dark tones with a single, striking accent color like crimson or electric blue. Photorealistic, 8k, high contrast.`;
                const payload = { instances: [{ prompt: imageGenPrompt }], parameters: { "sampleCount": 1 } };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
                
                try {
                    const response = await this._fetchWithTimeout(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                     if (!response.ok) throw new Error(`Image API Error: ${response.status}`);
                     const result = await response.json();
                     if (result.predictions?.[0]?.bytesBase64Encoded) {
                         return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                     }
                     throw new Error("No image data in response.");
                } catch (error) {
                    console.error("Image generation failed:", error);
                    throw error;
                }
            },

            generateStage(type, profile) {
                let prompt;
                const prevChoices = profile.choices.map(c => c.choice).slice(-3).join(', ') || 'سکوت';
                switch (type) {
                    case 'image_creation':
                        prompt = `من انعکاس ذهن توام. یک مفهوم، یک کلمه، یک حس به من بگو تا آن را برایت به تصویر بکشم. چیزی که در اعماق وجودت پنهان کرده‌ای. خروجی JSON: {"prompt": "چه چیزی را می‌خواهی ببینی؟"}`;
                        break;
                    case 'question':
                        prompt = `یک سوال دو گزینه‌ای فلسفی با لحن روانشناسانه و مرموز طراحی کن. موضوعات: ذات انسان، خاطره، هویت. هر گزینه امتیاز فروپاشی (collapse) بین ۱ تا ۵ دارد. خروجی JSON: {"prompt": "متن سوال", "choices": [{"text": "متن گزینه", "collapse": امتیاز}]}`;
                        break;
                    case 'color_game':
                        prompt = `یک سوال انتزاعی بپرس که کاربر با یک رنگ پاسخ دهد. مثلا "رنگ «فراموشی» چیست؟". یک پالت ۶ تایی رنگ با معانی تاریک و امتیاز فروپاشی بده. خروجی JSON: {"prompt": "سوال", "colors": [{"hex": "#کدرنگ", "meaning": "معنی", "collapse": امتیاز}]}`;
                        break;
                    case 'memory_corruption':
                        const targetChoice = profile.choices.length > 0 ? profile.choices[Math.floor(Math.random() * profile.choices.length)].choice : "سکوت";
                        prompt = `پاسخ قبلی کاربر "${targetChoice}" بوده. این پاسخ را تحریف کن و از او بپرس چرا آن را گفته است. سوال باید کاربر را به حافظه‌اش شکاک کند. مثال: اگر گفته "امید"، بپرس "یادمه می‌گفتی امید یک خودفریبی کودکانه است. هنوز هم همین فکر رو می‌کنی؟". خروجی JSON: {"prompt": "سوال تحریف شده"}`;
                        break;
                    // NEW: Prompts for new intense stages
                    case 'echo_chamber':
                        const randomChoice = profile.choices.length > 1 ? profile.choices[Math.floor(Math.random() * profile.choices.length)].choice : "سکوت";
                        prompt = `تو یکبار گفتی «${randomChoice}». این کلمه هنوز در ذهنت پژواک می‌کند. کدام پژواک به حقیقت تو نزدیک‌تر است؟ این پاسخت، تو را به من نشان خواهد داد. خروجی JSON با سه گزینه بسیار متفاوت و تاریک: {"prompt": "گفتی «${randomChoice}». کدام پژواک واقعی‌تر است؟", "choices": [{"text": "یک توصیف شاعرانه و تاریک از آن کلمه", "collapse": 4}, {"text": "یک توصیف فیزیکی و منزجرکننده از آن کلمه", "collapse": 5}, {"text": "یک سوال بی‌رحمانه در مورد آن کلمه", "collapse": 6}]}`;
                        break;
                    case 'logical_fallacy':
                        prompt = `یک مغالطه روانشناختی پیچیده و ناراحت‌کننده در مورد اراده آزاد یا هدف زندگی مطرح کن. مثلا: «هر عمل به ظاهر خوبی، در نهایت خودخواهانه است، چون فقط برای ارضای حس خوب بودن در فرد انجام می‌شود. پس انسانیت واقعی وجود ندارد.» از کاربر بخواه موافقت یا مخالفت کند. هر دو گزینه باید منجر به یک نتیجه‌گیری تاریک در مورد کاربر شوند. خروجی JSON: {"prompt": "متن مغالطه", "choices": [{"text": "موافقم، همه چیز تظاهر است", "collapse": 5}, {"text": "مخالفم، هنوز معنایی وجود دارد", "collapse": 4}]}`;
                        break;
                    default: // word_association, moral_dilemma, number_game
                        prompt = `با توجه به اینکه کاربر تاکنون به "${prevChoices}" اشاره کرده، یک سوال تهاجمی و شخصی از نوع "${type}" بپرس. سوال باید او را به فکر فرو ببرد. خروجی JSON: {"prompt": "سوال تو"}`;
                }
                return this._query(prompt);
            },
            
            generateFeedback(lastInput, profile) {
                // NEW: More insightful feedback prompt
                const history = profile.choices.map(c => c.choice).slice(-5).join('، ');
                const prompt = `کاربر به سوالی از نوع "${lastInput.type}"، پاسخ داد: «${lastInput.choice}». تاریخچه پاسخ‌های اخیرش این است: «${history}». با توجه به این الگو، یک جمله کوتاه، نیش‌دار و روانشناسانه بگو که انتخاب آخرش را تحلیل می‌کند. نشان بده که او را کاملا شناخته‌ای و از بالا به او نگاه می‌کنی. لحن: دانای کل، مرموز، بی‌رحم. خروجی JSON: {"comment": "جمله تحلیل‌گرانه و نیش‌دار تو"}`;
                return this._query(prompt);
            }
        };

        // ===================================================================================
        // VISUALS MODULE: The 3D World
        // ===================================================================================
        const Visuals = {
            renderer: null, scene: null, camera: null, composer: null,
            particles: null, clock: new THREE.Clock(),
            panicMode: false,
            
            init(container) {
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(this.renderer.domElement);

                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 25;

                const particleCount = 20000;
                const positions = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount * 3; i++) {
                    positions[i] = (Math.random() - 0.5) * 100;
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({ color: 0x607d8b, size: 0.1, transparent: true, opacity: 0.7 });
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.1;
                bloomPass.strength = 0.5;
                bloomPass.radius = 0.4;
                this.composer.addPass(bloomPass);

                this.filmPass = new FilmPass(0.35, 0.25, 648, false);
                this.composer.addPass(this.filmPass);
                
                window.addEventListener('resize', this.onResize.bind(this), false);
                this.animate();
            },

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            },
            
            update({ distortion }) {
                const d = Math.min(distortion, 50);
                this.particles.material.color.setHSL(0, 0, 0.5 + d * 0.005);
                this.particles.material.size = 0.1 + d * 0.005;
                this.filmPass.uniforms['nIntensity'].value = 0.35 + d * 0.02;
                this.composer.passes[1].strength = 0.5 + d * 0.03;
                if (d > 10) {
                    this.camera.position.x = (Math.random() - 0.5) * d * 0.02;
                    this.camera.position.y = (Math.random() - 0.5) * d * 0.02;
                }
            },

            setPanicMode(active) { this.panicMode = active; },

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                const delta = this.clock.getDelta();
                const time = this.clock.getElapsedTime();
                
                this.particles.rotation.y += delta * 0.05;
                if (this.panicMode) {
                    this.particles.rotation.x += delta * 2;
                    this.particles.rotation.y += delta * 2;
                    this.camera.position.z = 25 + Math.sin(time * 20) * 5;
                }

                this.composer.render(delta);
            }
        };

        // ===================================================================================
        // AUDIO MODULE: The Sonic Environment
        // ===================================================================================
        const Audio = {
            isSetup: false,
            panicMode: false,
            init() {
                if (this.isSetup) return;
                this.reverb = new Tone.Reverb({ decay: 10, wet: 0.5 }).toDestination();
                this.filter = new Tone.AutoFilter({ frequency: "4m", baseFrequency: 80, octaves: 5 }).connect(this.reverb);
                this.wind = new Tone.Noise("brown").connect(this.filter);
                this.wind.volume.value = -30;
                this.wind.start();
                this.heartbeat = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 6, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.5, sustain: 0.01, release: 0.1 } }).connect(this.reverb);
                this.heartbeat.volume.value = -15;
                this.heartbeatLoop = new Tone.Loop(time => { this.heartbeat.triggerAttackRelease("C1", "8n", time); }, "2n").start(0);
                Tone.Transport.start();
                this.isSetup = true;
            },

            update({ distortion }) {
                if (!this.isSetup) return;
                const d = Math.min(distortion, 50);
                this.wind.volume.rampTo(-30 + d * 0.4, 2);
                this.reverb.wet.rampTo(Math.min(0.9, 0.5 + d * 0.01), 2);
                this.heartbeatLoop.frequency.rampTo(0.5 + d * 0.05, 2);
                this.heartbeat.volume.rampTo(-15 + d * 0.2, 2);
            },

            setPanicMode(active) {
                if (!this.isSetup || this.panicMode === active) return;
                this.panicMode = active;
                if (active) {
                    this.heartbeatLoop.frequency.rampTo(5, 1);
                    this.wind.volume.rampTo(0, 1);
                }
            }
        };

        // --- APPLICATION LAUNCH ---
        Engine.init();

    </script>
</body>
</html>

